<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://kkyflying.github.io/</id><title>kky</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2025-07-21T22:06:56+08:00</updated> <author> <name>kky</name> <uri>https://kkyflying.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://kkyflying.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://kkyflying.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 kky </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>HDMI CEC (1)</title><link href="https://kkyflying.github.io/posts/Android-CEC-1/" rel="alternate" type="text/html" title="HDMI CEC (1)" /><published>2024-11-18T22:34:09+08:00</published> <updated>2024-11-18T22:34:09+08:00</updated> <id>https://kkyflying.github.io/posts/Android-CEC-1/</id> <content src="https://kkyflying.github.io/posts/Android-CEC-1/" /> <author> <name>kky</name> </author> <category term="Android" /> <category term="Framework" /> <category term="HDMI" /> <summary> 前言 以下分析基于android14 CEC（Consumer Electronics Control）信号通过13引脚传输，作为HDMI接口的一部分。CEC总线作为控制信号被分离出来，使得在不增加数据占用宽带的情况下完成高速复杂的通信要求 这优先分析一下，是怎么和cec设备通信的，也就是收发的过程 HdmiControlService frameworks/base/services/core/java/com/android/server/hdmi/HdmiControlService.java cec的相关内容都在HdmiControlService里具体实现 在frameworks/base/core/java/android/content/Context.java里查看 /** * Use with {@link #getSystemSe... </summary> </entry> <entry><title>不同路径</title><link href="https://kkyflying.github.io/posts/dp-diff-path/" rel="alternate" type="text/html" title="不同路径" /><published>2024-06-13T22:56:28+08:00</published> <updated>2024-06-13T22:56:28+08:00</updated> <id>https://kkyflying.github.io/posts/dp-diff-path/</id> <content src="https://kkyflying.github.io/posts/dp-diff-path/" /> <author> <name>kky</name> </author> <category term="算法" /> <category term="动态规划" /> <summary> 不同路径1 从一个m*n网格的最左上角开始，每次只能向下或者向右移动一步，试图达到网格的最右下角，问：共有多少条不同的路？ 从上的网格来看，水平方向为i，竖直方向为j，到格子(i,j)的位置的路线是由正上方（i,j-1）和左边的（i-1，j）的和 确定dp数组以及下标的定义 (0,0)是起点，（i,j）是终点，dp[i][j]从(0,0)到(i,j)有多少条路径 确定递推公式 dp[i][j]=dp[i][j-1] + dp[i-1][j] dp数组初始化 当在dp[0][0]的时候，就是只有一条路，而到dp[0][j]和dp[i][0]的时候都是只有一条路，因为d[0][0]=dp[i][0]=dp[0][j]=1 确定遍历顺序 因为需要依赖正上方和左边的数据... </summary> </entry> <entry><title>dumpsys源码流程分析</title><link href="https://kkyflying.github.io/posts/dumpsys/" rel="alternate" type="text/html" title="dumpsys源码流程分析" /><published>2024-04-11T23:39:08+08:00</published> <updated>2024-04-11T23:39:08+08:00</updated> <id>https://kkyflying.github.io/posts/dumpsys/</id> <content src="https://kkyflying.github.io/posts/dumpsys/" /> <author> <name>kky</name> </author> <category term="Android" /> <category term="Framework" /> <summary> 1.源码入口 frameworks/native/cmds/dumpsys/main.cpp int main(int argc, char* const argv[]) { signal(SIGPIPE, SIG_IGN); sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager(); fflush(stdout); if (sm == nullptr) { ALOGE("Unable to get default service manager!"); std::cerr &amp;lt;&amp;lt; "dumpsys: Unable to get default service manager!" &amp;lt;&amp;lt; std::endl; return 20; } Dumpsys dum... </summary> </entry> <entry><title>01背包-滚动数组</title><link href="https://kkyflying.github.io/posts/dp-01-package-2/" rel="alternate" type="text/html" title="01背包-滚动数组" /><published>2023-12-07T23:06:47+08:00</published> <updated>2023-12-07T23:06:47+08:00</updated> <id>https://kkyflying.github.io/posts/dp-01-package-2/</id> <content src="https://kkyflying.github.io/posts/dp-01-package-2/" /> <author> <name>kky</name> </author> <category term="算法" /> <category term="动态规划" /> <summary> dp[i][j]是二维数组，从逻辑上来讲确实更好理解，但是代码上可以却是有优化空间，可以把dp[i][j]二维数组优化成dp[i]一维数组-&amp;gt;就是滚动数组 在使用二维数组的时候，递推公式： dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight(i)]+vlaue(i)) 物品编号i\背包重量j 0 1 2 3 4 物品0 0 15 15 15 15 物品1 0 15 15 20 35 物品2 0 15 ... </summary> </entry> <entry><title>MessageQueue的Native方法分析</title><link href="https://kkyflying.github.io/posts/Handler-native/" rel="alternate" type="text/html" title="MessageQueue的Native方法分析" /><published>2023-09-14T23:30:49+08:00</published> <updated>2023-09-14T23:30:49+08:00</updated> <id>https://kkyflying.github.io/posts/Handler-native/</id> <content src="https://kkyflying.github.io/posts/Handler-native/" /> <author> <name>kky</name> </author> <category term="Android" /> <category term="Handler" /> <summary> 前置 Handler并没有直接调用native，而是通过MessageQueue 相关的主要native代码 frameworks/base/core/jni/android_os_MessageQueue.cpp system/core/libutils/Looper.cpp MessageQueue.java中native方法的分析 路径 frameworks/base/core/jni/android_os_MessageQueue.cpp 可以看到MessageQueue的native方法 private native static long nativeInit(); private native static void nativeDestroy(long ptr); private native void nativePollOnce(long ptr, int... </summary> </entry> </feed>
