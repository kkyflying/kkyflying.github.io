[ { "title": "HDMI CEC (1)", "url": "/posts/Android-CEC-1/", "categories": "Android, Framework, HDMI", "tags": "Android, Framework", "date": "2024-11-18 22:34:09 +0800", "snippet": "前言 以下分析基于android14 CEC（Consumer Electronics Control）信号通过13引脚传输，作为HDMI接口的一部分。CEC总线作为控制信号被分离出来，使得在不增加数据占用宽带的情况下完成高速复杂的通信要求 这优先分析一下，是怎么和cec设备通信的，也就是收发的过程HdmiControlServiceframeworks/base/services/core/java/com/android/server/hdmi/HdmiControlService.javacec的相关内容都在HdmiControlService里具体实现在frameworks..." }, { "title": "不同路径", "url": "/posts/dp-diff-path/", "categories": "算法, 动态规划", "tags": "动态规划", "date": "2024-06-13 22:56:28 +0800", "snippet": "不同路径1从一个m*n网格的最左上角开始，每次只能向下或者向右移动一步，试图达到网格的最右下角，问：共有多少条不同的路？从上的网格来看，水平方向为i，竖直方向为j，到格子(i,j)的位置的路线是由正上方（i,j-1）和左边的（i-1，j）的和 确定dp数组以及下标的定义 (0,0)是起点，（i,j）是终点，dp[i][j]从(0,0)到(i,j)有多少条路径 确定递推公式 dp[i][j]=dp[i][j-1] + dp[i-1][j] dp数组初始化 当在dp[0][0]的时候，就是只有一条路，而到dp[0][j]和dp[i][0..." }, { "title": "dumpsys源码流程分析", "url": "/posts/dumpsys/", "categories": "Android, Framework", "tags": "Android, Framework", "date": "2024-04-11 23:39:08 +0800", "snippet": "1.源码入口 frameworks/native/cmds/dumpsys/main.cpp int main(int argc, char* const argv[]) { signal(SIGPIPE, SIG_IGN); sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager(); fflush(stdout); if (sm == nullptr) { ALOGE(&quot;Unable to get default service manager!&quot;); std::cerr &..." }, { "title": "01背包-滚动数组", "url": "/posts/dp-01-package-2/", "categories": "算法, 动态规划", "tags": "动态规划", "date": "2023-12-07 23:06:47 +0800", "snippet": "dp[i][j]是二维数组，从逻辑上来讲确实更好理解，但是代码上可以却是有优化空间，可以把dp[i][j]二维数组优化成dp[i]一维数组-&amp;gt;就是滚动数组在使用二维数组的时候，递推公式：dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight(i)]+vlaue(i)) 物品编号i\\背包重量j 0 1 2 3 4 物品0 0 15 15 15 15 物品1 0 ..." }, { "title": "MessageQueue的Native方法分析", "url": "/posts/Handler-native/", "categories": "Android, Handler", "tags": "Android, Handler, MessageQueue, Native", "date": "2023-09-14 23:30:49 +0800", "snippet": "前置Handler并没有直接调用native，而是通过MessageQueue相关的主要native代码frameworks/base/core/jni/android_os_MessageQueue.cppsystem/core/libutils/Looper.cppMessageQueue.java中native方法的分析路径 frameworks/base/core/jni/android_os_MessageQueue.cpp可以看到MessageQueue的native方法private native static long nativeInit();private nativ..." }, { "title": "java基本类型的理解", "url": "/posts/java-type/", "categories": "java", "tags": "java", "date": "2023-01-04 23:40:24 +0800", "snippet": "前提补充 位移运算计算机中存的都是数的补码，所以位移运算都是对补码而言的 左移&amp;lt;&amp;lt; ， 右补0 有符号右移&amp;gt;&amp;gt; 左补符号位，即：如果符号位是1 就左补1，如果符号位是0 就左补0 无符号右移&amp;gt;&amp;gt;&amp;gt; ，统一左补0 原码反码补码关系 正数下，原码=反码=补码 负数下，原码=反码除符号位不变，其余全部取反,补码=反码+1 计算机中统一用补码的原因 使用补码，可以将符号位和其它位统一处理 减法也可按加法来处理 ..." }, { "title": "完全背包", "url": "/posts/dp-all-package/", "categories": "算法, 动态规划", "tags": "动态规划", "date": "2022-12-05 23:17:24 +0800", "snippet": " 物品编号 重量w 价值v 0 1 15 1 3 20 2 4 30 背包的最大重量为4，每个物品可以装一次或者多次或者不装，问装满这个背包的最大价值是多少？动态规划解法1. 确定dp数组的以及下标的含义 i是物品的编号，j是背包重量 dp[i][j]是当背包重量为j的时候，在[0,i]物品之间任取n个物品，所的到最大价值2. 确定递推公式不放入第i物品 当背包重量为j并j&amp;gt..." }, { "title": "01背包", "url": "/posts/dp-01-package/", "categories": "算法, 动态规划", "tags": "动态规划", "date": "2022-12-05 23:03:57 +0800", "snippet": "动态规划必备5步骤! 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组参考链接动态规划的解题步骤01背包 物品编号 重量w 价值v 0 1 15 1 3 20 2 4 30 背包的最大重量为4，每个物品只能最多装一次或者不装，问装满这个背包的最大价值是多少？暴力解法回溯算法，枚举所有情况，如果是n个物品，那么时间复杂度是..." }, { "title": "Handler分析", "url": "/posts/Handler/", "categories": "Android, Handler", "tags": "Android, Handler", "date": "2022-06-19 12:29:31 +0800", "snippet": "1. Handler相关类总结 Handler ：用于发送和接收消息,是最外层的入口 Message：消息实体,实现了Parcelable接口,内部实现了单链表 Looper ：用于轮询消息队列，一个线程只有一个Looper MessageQueue：消息队列，用于存储消息和管理消息 ThreadLocal : 提供线程本地变量的存储在把上述的5个类都分析一遍后,可以发现重点逻辑都在MessageQueue,Looper,ThreadLocal则是实现功能的基础,Handler仅仅只是一个最外层的入口而已,并没有太多的重要的逻辑2. Handler构造方法flowchart T..." }, { "title": "Looper分析", "url": "/posts/Loop/", "categories": "Android, Handler", "tags": "Android, Handler, Looper", "date": "2022-05-08 19:44:52 +0800", "snippet": "1. Looper的简单介绍/** * Class used to run a message loop for a thread. Threads by default do * not have a message loop associated with them; to create one, call * {@link #prepare} in the thread that is to run the loop, and then * {@link #loop} to have it process messages until the loop is stoppe..." }, { "title": "IdleHandler分析", "url": "/posts/IdleHandler/", "categories": "Android, Handler", "tags": "Android, Handler, MessageQueue, IdleHandler", "date": "2022-05-01 11:16:33 +0800", "snippet": "1. IdleHandler的简单介绍/*** Callback interface for discovering when a thread is going to block* waiting for more messages.*/public static interface IdleHandler {/*** Called when the message queue has run out of messages and will now* wait for more. Return true to keep your idle handler active, false*..." }, { "title": "结构体对齐", "url": "/posts/struct_align/", "categories": "C/C++", "tags": "C/C++", "date": "2022-04-22 22:29:22 +0800", "snippet": "简单介绍 结构体的占用大小在大多数情况下都不会直接等于各个成员大小的总和,因为会有一个对齐内存的操作 为了移植原因,这是在不同的平台下,如果没有对齐可能会抛出异常 为了提高CPU的读取效率,因为CPU一般都是内存读取都是以N的整数倍,如果没有对齐,就可能需要读取两次才能将数据读完,而对齐后,可以一次性读完数据,提高效率对齐规则规则1struct Data{ char c; short s; int i;};int main(){ int c=sizeof(char); int s=sizeof(short); int i=sizeof(int);..." }, { "title": "字节序", "url": "/posts/Endian/", "categories": "C/C++", "tags": "C/C++", "date": "2022-03-26 23:53:31 +0800", "snippet": "1. 基本概念 字节序就是超过一个字节的数据类型在内存中的存放顺序，通常需要在跨平台和网络相关的开发中需要留意的问题 字节序不是由操作系统决定的，而是由CPU架构所决定的2. 大小端字节序被分为两个类型 大端：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端 小段：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端3. 判断当前设备是那一种字节序1. 通过一个简单的demo来分析#include &amp;lt;stdio.h&amp;gt;int a=1;int b=2;int main(){ printf(&quot;&amp;amp;a=%p\\n&quot..." }, { "title": "MessageQueue分析", "url": "/posts/MessageQueue/", "categories": "Android, Handler", "tags": "Android, Handler, MessageQueue", "date": "2022-02-13 14:24:12 +0800", "snippet": "1. MessageQueue的简单介绍/** * Low-level class holding the list of messages to be dispatched by a * {@link Looper}. Messages are not added directly to a MessageQueue, * but rather through {@link Handler} objects associated with the Looper. * * &amp;lt;p&amp;gt;You can retrieve the MessageQueue for th..." }, { "title": "ThreadLocal分析", "url": "/posts/ThreadLocal/", "categories": "Android, Handler", "tags": "Android, Handler, ThreadLocal", "date": "2021-03-24 23:26:31 +0800", "snippet": "1. ThreadLocal的简单介绍/** * This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable. {@code ThreadLocal} ins..." }, { "title": "AndroidAutoSize 1.2.1 源码分析", "url": "/posts/AndroidAutoSize/", "categories": "Android, 适配方案", "tags": "Android, AndroidAutoSize", "date": "2021-02-16 20:33:10 +0800", "snippet": "1. 源码地址AndroidAutoSize注：在这份框架源码里，尽管框架的作者添加十分详尽的注释，但是本人在查阅后还是决定写下这份简略的分析，以加深印象，在此感谢框架的作者的开源。2. 流程1. 框架入口 根据文档readme说明，只要AndroidManifest 中填写全局设计图尺寸 (单位 dp)，框架就可以自动对所有页面进行适配，那么就从这里入手。 &amp;lt;manifest&amp;gt; &amp;lt;application&amp;gt; &amp;lt;meta-data andr..." }, { "title": "Android分辨率", "url": "/posts/android_resolution/", "categories": "Android, 适配方案", "tags": "Android", "date": "2021-01-08 18:30:28 +0800", "snippet": "概念1. dpi(dots-per-inch)像素密度每英尺像素数2. dp(Density Independent Pixel)dp 是一个虚拟像素单位，1 dp 约等于中密度屏幕（160dpi；“基准”密度）上的 1 像素。对于其他每个密度，Android 会将此值转换为相应的实际像素数。（注：早期android定义为dip，后改城dp，即是dip=dp）3. sp(Scale Independent Pixel)在定义文本大小时，您应改用可缩放像素 (sp) 作为单位（但切勿将 sp 用于布局尺寸）。默认情况下，sp 单位与 dp 大小相同，但它会根据用户的首选文本大小来调整大小。..." }, { "title": "RK-Android-Usb无法读取以及原理分析 ", "url": "/posts/RK-Android-Usb/", "categories": "Android, Framework", "tags": "Android, Framework, RK", "date": "2018-06-12 18:50:24 +0800", "snippet": "前言如果你不知道RK是啥玩意,请先google或者baidu (:з」∠)环境 RK3368 Android 6.0.1需要解决的问题当设备接入U盘的后,RK全家桶都读不到U盘里的多媒体的资源,例如:mp4,mp3之类的. (不幸的是,这个功能是客户的刚需.)解决方案分析过程1. 虽然RK全家桶都没有读到U盘里的数据,但是在文件夹管理器上却可以看到挂载上去的U盘,点击进去也能看到U盘里的资料,当时是判断为可能RK全家桶有点问题,回头就去下载了RK的RockVideoPlayer源码来分析.2. 在RockVideoPlayer.java下就能看到这个播放器的基本原理了,在onCrea..." }, { "title": "Android系统-预安装应用", "url": "/posts/Android_Framework_pre_install_app/", "categories": "Android, Framework", "tags": "Android, Framework", "date": "2018-05-10 14:19:21 +0800", "snippet": "前言一般打包Android固件都会有一些不可避免的操作,在此分享一下,逐渐更新完善.Android系统预安装应用一般做定制的固件，都是给某个客户使用的，客户多数会要求预先安装他们提供的apk，开启自启动（这个apk里面可以完成）。1.先分析这个apk，这个时候，可以直接解压，或者AS查看下，或者jadx，看看里面是否有so文件，如果没有可以跳过到下一步了，如果看到so库的话，解压出来。（注 : 用Test.apk来作为例子）2.找到源码下的./vendor/rockchip/common/apps , 在这个目录下新建一个包，可以随便起名，这里举例Test，把Test.apk和so(如果..." }, { "title": "Android系统-修改开机动画", "url": "/posts/Android_Framework_Start_Animation/", "categories": "Android, Framework", "tags": "Android, Framework", "date": "2018-05-03 09:56:05 +0800", "snippet": "前言一般打包Android固件都会有一些不可避免的操作,在此分享一下,逐渐更新完善.修改Android开机动画先吐槽一下Android的开机动画,因为这个动画是依靠很多图片堆起来的,可以理解为放了个GIF图上去,但是相对的,这个操作就变得很容易了.1.把全部图片都按照顺序命名好,并且放在android文件夹下,例如:2.新建desc.txt文件,写入1366 768 10p 0 0 android3.把android文件和desc.txt一起压缩(.zip格式),并且改名为bootanimation4.把这个bootanimation.zip发到 ./device/rockchip/co..." }, { "title": "Nginx + Gunicorn + Django 部署", "url": "/posts/Server_Config_Nginx_Gunicorn_django/", "categories": "Server", "tags": "Nginx, Gunicorn, Django", "date": "2017-10-12 18:38:22 +0800", "snippet": "前言 看到很多django的部署都是nginx + uwsgi 来实现，我只能说赶紧抛弃uwsgi投入gunicorn的怀抱！！！使用uwsgi需要做复杂的配置，而gunicorn只需要很简单的配置即可启动，还能兼容eventlet, gevent, tornado, gthread, gaiohttp。django官网的对uwsgi介绍django官网的对gunicorn介绍gunicorn官网使用gunicorn启动django的命令如下：gunicorn -b 127.0.0.1:8000 --worker-class=gevent yourProject.wsgi–worker..." }, { "title": "服务器应用的配置小记录笔记", "url": "/posts/Server_Config_Tomcat_Nginx/", "categories": "Server", "tags": "Tomcat, Nginx", "date": "2017-10-12 11:32:05 +0800", "snippet": "修改Tomcat的默认目录在/tomcat/conf/下vim server.xml把原本的 appBase=”webapps” ,修改成你要设置的目录如下修改nginx的默认目录在nginx/conf/下vim nginx.conf要把第一个location的root都要改了，下面的location修改才会生效" }, { "title": "关于Android Zxing 3.3.0 的填坑", "url": "/posts/Android_Zxing/", "categories": "Android", "tags": "Android, Zxing", "date": "2017-08-03 00:25:28 +0800", "snippet": "前言一开始公司的项目已经集成了Zxing,也实现了扫二维码的功能,但是前一阵子,领导发现在扫码的时候,预览的成像有问题.当时让我去修改,但是我发现公司用的zxing版本比较新,用的3.3.0的版本,我当时在网上大概的找了一些,并没有找到这个版本直接的具体修改方案,但是却提供了思路.最后我是填了一些坑,完成了任务,然后我还把这些代码都集成到一个库中.因此本文重点是讲如何填坑 扫描预览走样 扫描框走样源码地址 使用方法都在github的README上面了,所以本文并不会再次讲解.正文Zxing 扫描走样先上一个图说明一下原来的问题:(因为整个手机截图的图片比较大,我就放上关键的地方)图1..." } ]
