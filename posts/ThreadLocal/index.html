<!DOCTYPE html><html lang="en-US" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="ThreadLocal分析" /><meta name="author" content="kky" /><meta property="og:locale" content="en_US" /><meta name="description" content="1. ThreadLocal的简单介绍" /><meta property="og:description" content="1. ThreadLocal的简单介绍" /><link rel="canonical" href="https://kkyflying.github.io/posts/ThreadLocal/" /><meta property="og:url" content="https://kkyflying.github.io/posts/ThreadLocal/" /><meta property="og:site_name" content="kky" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-24T23:26:31+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ThreadLocal分析" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@kky" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kky"},"dateModified":"2022-02-13T14:44:13+08:00","datePublished":"2021-03-24T23:26:31+08:00","description":"1. ThreadLocal的简单介绍","headline":"ThreadLocal分析","mainEntityOfPage":{"@type":"WebPage","@id":"https://kkyflying.github.io/posts/ThreadLocal/"},"url":"https://kkyflying.github.io/posts/ThreadLocal/"}</script><title>ThreadLocal分析 | kky</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/icon.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">kky</a></div><div class="site-subtitle font-italic">芜湖，起飞～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/kkyflying" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kkyflying','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>ThreadLocal分析</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>ThreadLocal分析</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 24, 2021, 11:26 PM +0800" > Mar 24, 2021 <i class="unloaded">2021-03-24T23:26:31+08:00</i> </span> by <span class="author"> kky </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Feb 13, 2022, 2:44 PM +0800" > Feb 13, 2022 <i class="unloaded">2022-02-13T14:44:13+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4411 words">24 min</span></div></div><div class="post-content"><h2 id="1-threadlocal的简单介绍">1. ThreadLocal的简单介绍</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cm">/**
 * This class provides thread-local variables.  These variables differ from
 * their normal counterparts in that each thread that accesses one (via its
 * {@code get} or {@code set} method) has its own, independently initialized
 * copy of the variable.  {@code ThreadLocal} instances are typically private
 * static fields in classes that wish to associate state with a thread (e.g.,
 * a user ID or Transaction ID).
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">//中间先省略</span>
<span class="o">}</span>
</pre></table></code></div></div><p>先看到ThreadLocal的定义和官方的注释介绍，ThreadLocal本身只是一个简单的class并且可以传入一个泛类，官方的意思是这个class可以提供线程本地变量的存储，不同于一般的变量，因为每一个线程只能get和set到当前对应线程的值，这些变量是相互独立的，可以很粗狂的理解为这是一个map，而用线程来当做key，独立的值为value。</p><h2 id="2-threadlocal使用">2. ThreadLocal使用</h2><ol><li><p><strong>demo</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">ThreadLocalTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">threadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
        <span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" value : "</span> <span class="o">+</span><span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
         <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="s">"thread-1"</span><span class="o">){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" value : "</span> <span class="o">+</span> <span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="s">"thread-2"</span><span class="o">){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" value : "</span> <span class="o">+</span> <span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="s">"thread-3"</span><span class="o">){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" value : "</span> <span class="o">+</span> <span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><li><p><strong>运行结果</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>main value : 0
thread-1 value : 1
thread-2 value : 2
thread-3 value : null
</pre></table></code></div></div><li><p><strong>使用说明</strong></p><p>通过这个简单的demo可以看出来,在不同线程下的get和set的值是互相独立不影响的,使用十分方便.一般来说,使用场景有两种,第一情况是:<strong>当某个数据需要以线程为作用域(或是key),并且不同线程下的数据必须独立不被影响的时候</strong>,例如在Android的Handler中就是使用了ThreadLocal来进行对Looper的管理,第二情况是:<strong>在十分复杂的逻辑下进行对象的传递</strong>,例如当需要把一个接口在一个线程中多次传递,并且在不同的线程下使用不同的接口来监听回调,正常下,需要为一个个方法添加这个接口的参数,进行一层层的传递,但是在后面修改逻辑,维护等工作上就会十分折磨,这个时候通过ThreadLocal现在线程初始start后,set保存一个接口,在逻辑需要回调接口的时候,直接get到这个接口,这样就不必在方法上添加接口参数,大大减少了工作量,具体实现在Java后台的实现比较多,可以参考<a href="https://stackoverflow.com/questions/7625922/purpose-and-use-of-threadlocal-class">stackoverflow上的一个回答</a></p></ol><h2 id="3-threadlocal分析">3. ThreadLocal分析</h2><ol><li><strong>ThreadLocal#set()</strong>和<strong>ThreadLocal#get()</strong><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    	<span class="c1">//获得当前的线程对象</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    	<span class="c1">//通过当前的线程获取到ThreadLocalMap</span>
        <span class="nc">ThreadLocalMap</span> <span class="n">map</span> <span class="o">=</span> <span class="n">getMap</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="c1">//如果map存在,则value存入到map,以当前的ThreadLocal为key</span>
            <span class="n">map</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="c1">//如果map不存在,创建一个新的ThreadLocalMap,并存入value</span>
            <span class="n">createMap</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    	<span class="c1">//获得当前的线程对象</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
   		<span class="c1">//通过当前的线程获取到ThreadLocalMap</span>
        <span class="nc">ThreadLocalMap</span> <span class="n">map</span> <span class="o">=</span> <span class="n">getMap</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//如果map不为空,则通过当的ThreadLocal为key获取e</span>
            <span class="nc">ThreadLocalMap</span><span class="o">.</span><span class="na">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getEntry</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//若e不为空,则通过这e获得value并返回</span>
                <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
                <span class="no">T</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span><span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    	<span class="c1">//如果map为空或者e为空,则返回设置的默认初始值</span>
        <span class="k">return</span> <span class="nf">setInitialValue</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>通过查看get()和set()方法,可以发现逻辑十分简单,重点在于ThreadLocalMap类(是ThreadLocal的静态内部类)以及getMap(),createMap(),setInitialValue()等方法.</p><li><p><strong>ThreadLocal#getMap()</strong>和<strong>ThreadLocal#createMap()</strong>以及<strong>ThreadLocal#setInitialValue()</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/**
* Get the map associated with a ThreadLocal. Overridden in
* InheritableThreadLocal.
*
* @param  t the current thread
* @return the map
*/</span>
<span class="nc">ThreadLocalMap</span> <span class="nf">getMap</span><span class="o">(</span><span class="nc">Thread</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">threadLocals</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cm">/* ThreadLocal values pertaining to this thread. This map is maintained
* by the ThreadLocal class. */</span>
<span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">ThreadLocalMap</span> <span class="n">threadLocals</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</pre></table></code></div></div><p>从getMap()中看到这个ThreadLocalMap竟然就是来自传入的Thread中的一个变量,而查看Thread中对这个变量的注释简单翻译来看,<em>这个ThreadLocal的值属于这个thread,这个map被ThreadLocal所维护持有</em>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/**
* Create the map associated with a ThreadLocal. Overridden in
* InheritableThreadLocal.
*
* @param t the current thread
* @param firstValue value for the initial entry of the map
*/</span>
<span class="kt">void</span> <span class="nf">createMap</span><span class="o">(</span><span class="nc">Thread</span> <span class="n">t</span><span class="o">,</span> <span class="no">T</span> <span class="n">firstValue</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">t</span><span class="o">.</span><span class="na">threadLocals</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocalMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">firstValue</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>根据注释来看,<em>通过当前ThreadLocal来构建一个ThreadLocalMap,并且把传入一个初始值firstValue来为map构建一个初始的entry</em>,而createMap()只在get(),set(),setInitialValue()中被调用.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cm">/**
* Variant of set() to establish initialValue. Used instead
* of set() in case user has overridden the set() method.
*
* @return the initial value
*/</span>
<span class="kd">private</span> <span class="no">T</span> <span class="nf">setInitialValue</span><span class="o">()</span> <span class="o">{</span>
	<span class="no">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">initialValue</span><span class="o">();</span>
	<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
	<span class="nc">ThreadLocalMap</span> <span class="n">map</span> <span class="o">=</span> <span class="n">getMap</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">map</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
		<span class="n">map</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
	<span class="k">else</span>
		<span class="nf">createMap</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>setInitialValue()和set()的逻辑几乎一模一样,可以理解为setInitialValue()干了一个事,获取了一个默认的value并传入set()中,在这里值得关注就是initialValue()了</p><li><p><strong>ThreadLocal#initialValue()</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cm">/**
* Returns the current thread's "initial value" for this
* thread-local variable.  This method will be invoked the first
* time a thread accesses the variable with the {@link #get}
* method, unless the thread previously invoked the {@link #set}
* method, in which case the {@code initialValue} method will not
* be invoked for the thread.  Normally, this method is invoked at
* most once per thread, but it may be invoked again in case of
* subsequent invocations of {@link #remove} followed by {@link #get}.
*
* &lt;p&gt;This implementation simply returns {@code null}; if the
* programmer desires thread-local variables to have an initial
* value other than {@code null}, {@code ThreadLocal} must be
* subclassed, and this method overridden.  Typically, an
* anonymous inner class will be used.
*
* @return the initial value for this thread-local
*/</span>
<span class="kd">protected</span> <span class="no">T</span> <span class="nf">initialValue</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这initialValue()可以被重写,如果直接使用ThreadLocal,而没有先set()设置参数,那么直接返回null,可以通过上面的demo代码验证了.而initialValue()的第一次调当在线程中通过get()获得参数时调用.除非事先调用了set(),在这种情况下,initialValue()将不会被调用在这个线程里,通常,initialValue()这个方法在每个线程中只会被调用一次,但是initialValue()方法也可能会被再一次调用,在之后调用了remove()再调用get()的情况.</p><li><p><strong>ThreadLocal#remove()</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cm">/**
* Removes the current thread's value for this thread-local
* variable.  If this thread-local variable is subsequently
* {@linkplain #get read} by the current thread, its value will be
* reinitialized by invoking its {@link #initialValue} method,
* unless its value is {@linkplain #set set} by the current thread
* in the interim.  This may result in multiple invocations of the
* {@code initialValue} method in the current thread.
*
* @since 1.5
*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
	<span class="nc">ThreadLocalMap</span> <span class="n">m</span> <span class="o">=</span> <span class="n">getMap</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
    	<span class="n">m</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>通过当前线程来删除ThreadLocal里的值.在这个线程里,如果这个threadlocal的值在随后调用了get()读取的话,将会被通过initialValue()重新初始化,除非这个值被set()方法被临时赋值,这可能导致在当前线程中多次调用initialValue()</p></ol><h2 id="4-threadlocalmap">4. ThreadLocalMap</h2><p>通过前面的铺垫分析,这些方法里都围绕着ThreadLocalMap进行操作,可见ThreadLocalMap才是ThreadLocal的核心部分,接下来将会对此进行详细的分析</p><ol><li><p><strong>ThreadLocalMap.Entry</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cm">/**
* The entries in this hash map extend WeakReference, using
* its main ref field as the key (which is always a
* ThreadLocal object).  Note that null keys (i.e. entry.get()
* == null) mean that the key is no longer referenced, so the
* entry can be expunged from table.  Such entries are referred to
* as "stale entries" in the code that follows.
*/</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span> <span class="kd">extends</span> <span class="nc">WeakReference</span><span class="o">&lt;</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;&gt;</span> <span class="o">{</span>
	<span class="cm">/** The value associated with this ThreadLocal. */</span>
    <span class="nc">Object</span> <span class="n">value</span><span class="o">;</span>
   
	<span class="nc">Entry</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
		<span class="kd">super</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Entry类是ThreadLocalMap的静态内部类，并继承了WeakReference，对ThreadLocal进行弱引用，对value进行强引用</p><li><p><strong>ThreadLocalMap和Entry的关系</strong> 首先ThreadLocalMap确实是一个map，通过Entry[] table实现，而通过ThreadLocal#set()方法保存的值就到保存到了Entry类中的value，同时因为Entry的value是Object类型，ThreadLocalMap中实际上是可以保存不同类型的数据。</p><li><p><strong>ThreadLocalMap</strong>和<strong>ThreadLocal</strong>以及<strong>Thread</strong>三者的关系</p><ol><li><p>Thread类中持有着ThreadLocalMap变量，ThreadLocal通过获得Thread.currentThread()获得当前Thread对象来间接操作ThreadLocalMap</p><li><p><strong>每一个Thread中都只有一个ThreadLocalMap</strong>(虽然还有一个inheritableThreadLocals变量也是ThreadLocalMap，但是具体实现是InheritableThreadLocal，InheritableThreadLocal是ThreadLocalMap的子类)</p><li><p>就对于一个ThreadLocal来讲，在不同Thread下是操作不同的ThreadLocalMap(即是操作不同的table)，而对于多个ThreadLocal在同一个Thread下是操作同一个ThreadLocalMap(即是操作相同table，然后每个ThreadLocal实例在table中索引i是不同的)</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
<span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
<span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
</pre></table></code></div></div><p>如上，现在有三个ThreadLocal对象abc,都在主线程下操作，此时都对同一个ThreadLocalMap进行操作，即是对table操作，这个时候的问题就在于，abc在set()和get()过程中如何确定在table数组中的位置，同时保证这个位置不冲突。</p></ol><li><p><strong>ThreadLocalMap构造方法以及set()和get()</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cm">/**
* Construct a new map initially containing (firstKey, firstValue).
* ThreadLocalMaps are constructed lazily, so we only create
* one when we have at least one entry to put in it.
*/</span>
<span class="nc">ThreadLocalMap</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">firstKey</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">firstValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//初始table，容量是16</span>
	<span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">[</span><span class="no">INITIAL_CAPACITY</span><span class="o">];</span>
    <span class="c1">//通过hash来计算出存放的位置，这个算法后面还会具体将到</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">firstKey</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="no">INITIAL_CAPACITY</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">firstKey</span><span class="o">,</span> <span class="n">firstValue</span><span class="o">);</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">setThreshold</span><span class="o">(</span><span class="no">INITIAL_CAPACITY</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这个构造方法里要传入key和value，ThreadLocalMaps是被懒加载，只有第一次要存入数据的时候才调用，还要计算出第一次要存放在table中的位置</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="cm">/**
* Set the value associated with key.
*
* @param key the thread local object
* @param value the value to be set
*/</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// We don't use a fast path as with get() because it is at</span>
	<span class="c1">// least as common to use set() to create new entries as</span>
	<span class="c1">// it is to replace existing ones, in which case, a fast</span>
	<span class="c1">// path would fail more often than not.</span>
    <span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">//通过hash计算在tab中的存储位置</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="c1">//如果获取的e为空，则跳出循环，不为空的情况下，进入循环，通过Entry e.get()中是的</span>
    <span class="c1">//ThreadLocal对象和传入的key是否相同，如果相同则更新e.value的值，完成一次更新数据</span>
    <span class="c1">//（如何保证更新到正确的位置要依靠hash的计算，这个后面继续讲解）</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    	<span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    	<span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">)])</span> <span class="o">{</span>
        <span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>        
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        	<span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        	<span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//如果这个e.get()出来为空，则代替掉这个旧的Entry</span>
        	<span class="n">replaceStaleEntry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
     <span class="o">}</span>
     <span class="c1">//直接跳出上面的循环后，直接把数据保存tab中第i个位置</span>
     <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
     <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="o">++</span><span class="n">size</span><span class="o">;</span>
     <span class="c1">//如果有旧的Entry要清理通并且table的大小已经大于等于阀值则要重新计算hash</span>
     <span class="c1">//还要进行扩容</span>
     <span class="k">if</span> <span class="o">(!</span><span class="n">cleanSomeSlots</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">sz</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">sz</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="o">)</span>
     	<span class="n">rehash</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre> <span class="cm">/**
* Get the entry associated with key.  This method
* itself handles only the fast path: a direct hit of existing
* key. It otherwise relays to getEntryAfterMiss.  This is
* designed to maximize performance for direct hits, in part
* by making this method readily inlinable.
*
* @param  key the thread local object
* @return the entry associated with key, or null if no such
*/</span>
<span class="kd">private</span> <span class="nc">Entry</span> <span class="nf">getEntry</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//通过key的计算数据存储的位置</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="c1">//判断是否为空，以及key是否相同</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span>
    	<span class="k">return</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="nf">getEntryAfterMiss</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>ThreadLocalMap的构造方法以及set()和get()的关键点都是在计算table中i的位置</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">//构造方法</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">firstKey</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="no">INITIAL_CAPACITY</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
   
<span class="c1">//set（）</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
   
<span class="c1">//get()</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</pre></table></code></div></div><p>可以看到都和ThreadLocal的threadLocalHashCode有关，通过hashCode和length进行位运算确定出索引值i，i即是在table数组中的位置。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">threadLocalHashCode</span> <span class="o">=</span> <span class="n">nextHashCode</span><span class="o">();</span>
   
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">HASH_INCREMENT</span> <span class="o">=</span> <span class="mh">0x61c88647</span><span class="o">;</span>
   
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">nextHashCode</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">nextHashCode</span><span class="o">.</span><span class="na">getAndAdd</span><span class="o">(</span><span class="no">HASH_INCREMENT</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在每一次new出ThreadLocal的时候，threadLocalHashCode就被nextHashCode()初始化成为一个常量，并且每次threadLocalHashCode的初始化都会自增一次，增量为0x61c88647。</p><p>重点在于这个<code class="language-plaintext highlighter-rouge">HASH_INCREMENT=0x61c88647</code>，一个如此神奇的参数。</p></ol><h2 id="5-散列">5. 散列</h2><p>散列(Hash)也称为哈希，通俗点讲，就是无论输入端给什么数据，输出端都是一个数字；专业点，将输入映射到数字。而散列这必须满足一些要去。</p><ol><li><p>必须一致，同样的输入，必须每次得到相同的输出。</p><li><p>不同的输入应该要尽可能得到不同的数字，如果好几个不同输入都得到相同的输出，这就不是一个好的散列，最完美理想的情况下，不同的输入将映射到不同到的数字。</p></ol><h2 id="6-斐波那契数列">6. 斐波那契数列</h2><p><a href="https://www.bilibili.com/video/BV1is411E7df">详细请看李永乐老师的斐波那契数列讲解</a></p><p>斐波那契数列的递推式</p>\[a_1=a_2=1 \qquad a_n=a_{n-1}+a_{n-2}\]<p>例如数列是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>1 1 2 3 5 8 13 21 ... n 
</pre></table></code></div></div><p>通过前一项除以后一项等到以下，虽然大小是在变化，但是都会趋近于0.618这个数字，实际上就是黄金分割数</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>1/1=1
1/2=0.5
2/3=0.67
3/6=0.6
5/8=0.625
8/13=0.615
</pre></table></code></div></div>\[\frac{a_{n-1}}{a_n}\approx 0.618\]<h2 id="7-黄金分割">7. 黄金分割</h2><p><a href="https://www.bilibili.com/video/BV1Gs411L7Rf">详细请看李永乐老师的黄金分割讲解</a></p>\[\overline{a \qquad \qquad c \;\;\;\;\;\;\;b}\]<p>如上所示，令ab=1，ac=x，cb=1-x</p>\[\frac{1-x}{x}=\frac{x}{1} \\[2ex] \Rightarrow x^2+x-1=0 \\[2ex] \Rightarrow x=\frac{-1+\sqrt{5}}{2} \approx 0.618\]<h2 id="8-0x61c88647">8. 0x61c88647</h2><p>经过前面的铺垫，开始讲讲为何选择<code class="language-plaintext highlighter-rouge">HASH_INCREMENT=0x61c88647</code>一个如此神奇的参数</p><ol><li>进制的转换<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre> 十六进制
 0x61c88647
 十进制
 1640531527
 二进制
 1100001110010001000011001000111
</pre></table></code></div></div><li></ol><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>   <span class="kt">long</span> <span class="n">l1</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">((</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="o">)</span> <span class="o">*</span> <span class="o">((</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">));</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"as 32 bit unsigned: "</span> <span class="o">+</span> <span class="n">l1</span><span class="o">);</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"as 32 bit signed:   "</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">l1</span><span class="o">);</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MAGIC = "</span> <span class="o">+</span> <span class="mh">0x61c88647</span><span class="o">);</span>
</pre></table></code></div></div><p>可以看到<code class="language-plaintext highlighter-rouge">0x61c88647</code>与<code class="language-plaintext highlighter-rouge">(Math.sqrt(5) - 1)/2</code>产生了关系，而<code class="language-plaintext highlighter-rouge">(Math.sqrt(5) - 1)/2</code>即是0.618黄金切割</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre>   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
   	<span class="kt">int</span> <span class="no">HASH_INCREMENT</span> <span class="o">=</span> <span class="mh">0x61c88647</span><span class="o">;</span>
   	<span class="kt">int</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">15</span><span class="o">];</span>
   	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">15</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
   		<span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span> <span class="o">((</span><span class="no">HASH_INCREMENT</span><span class="o">*(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">))&amp;</span> <span class="mi">15</span><span class="o">);</span>
   	<span class="o">}</span>
   	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
   		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
   	<span class="o">}</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n-----------------------"</span><span class="o">);</span>
       <span class="c1">//为了方便查看是否有重复，对数据进行一次冒泡排序</span>
       <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
       	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
           	<span class="k">if</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]&lt;</span><span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
               	<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                   <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                   <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            	<span class="o">}</span>
        	<span class="o">}</span>
   	 <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
   <span class="o">}</span>
</pre></table></code></div></div><p>结果</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>   7 14 5 12 3 10 1 8 15 6 13 4 11 2 9 
   -----------------------
   15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
</pre></table></code></div></div><p>可以看到当容量是16的时候，均匀的分布在数组里，没有冲突。</p><h2 id="9-threadlocal与内存泄漏">9. ThreadLocal与内存泄漏</h2><p>因为ThreadLocalMap.Entry对ThreadLocal进行弱引用和对values进行强引用，但是它不会参考ReferenceQueue去发现那些弱引用被清除，即是ThreadLocal经过一次生命周期被回收了，value也不会被立即回收，因此造成了ThreadLocal的内存泄露。</p><p>这种情况毕竟容易出现的当线程属于线程池中，因为线程被重复使用，没有退出的话，而ThreadLocal为空后被回收，当时这个entry已经保存在table，如果不remove的话，就会把这个table变的越来越大，因此当使用完get()应该调用remove()清理掉数据。当然，如果只单独一个线程用完就退出的话，在exit()方法中就为threadLocals=null操作，这个时候就不会出现内存泄露。</p><p>来看看remove()的过程</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
	<span class="k">for</span> <span class="o">(</span><span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
		<span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">)])</span> <span class="o">{</span>
        <span class="c1">//通过threadLocalHashCode算计出key对应的index获得tab的entry</span>
        <span class="c1">//清理弱引用，并清理旧的entry</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
			<span class="n">expungeStaleEntry</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">int</span> <span class="nf">expungeStaleEntry</span><span class="o">(</span><span class="kt">int</span> <span class="n">staleSlot</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">ThreadLocalMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// 清空指定的value</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">].</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">staleSlot</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">size</span><span class="o">--;</span>

     <span class="c1">// Rehash until we encounter null</span>
     <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">ThreadLocalMap</span><span class="o">.</span><span class="na">Entry</span> <span class="n">e</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
     <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">staleSlot</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
         <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">))</span> <span class="o">{</span>
      	<span class="nc">ThreadLocal</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        	<span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">size</span><span class="o">--;</span>
         <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//重新计算index位置</span>
            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="na">threadLocalHashCode</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">//若果不在相同的位置，则老位置的清空，找到下个可以的位置，把e插入</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            	<span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                 <span class="c1">// Unlike Knuth 6.4 Algorithm R, we must scan until</span>
                 <span class="c1">// null because multiple entries could have been stale.</span>
                 <span class="k">while</span> <span class="o">(</span><span class="n">tab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
                 <span class="n">tab</span><span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
     <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
 <span class="o">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/android/'>Android</a>, <a href='/categories/handler/'>Handler</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >Android</a> <a href="/tags/handler/" class="post-tag no-text-decoration" >Handler</a> <a href="/tags/threadlocal/" class="post-tag no-text-decoration" >ThreadLocal</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ThreadLocal/">ThreadLocal分析</a><li><a href="/posts/Android_Zxing/">关于Android Zxing 3.3.0 的填坑</a><li><a href="/posts/Server_Config_Tomcat_Nginx/">服务器应用的配置小记录笔记</a><li><a href="/posts/Server_Config_Nginx_Gunicorn_django/">Nginx + Gunicorn + Django 部署</a><li><a href="/posts/Android_Framework_Start_Animation/">Android系统-修改开机动画</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/handler/">Handler</a> <a class="post-tag" href="/tags/framework/">Framework</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag" href="/tags/messagequeue/">MessageQueue</a> <a class="post-tag" href="/tags/c-c/">C/C++</a> <a class="post-tag" href="/tags/nginx/">Nginx</a> <a class="post-tag" href="/tags/androidautosize/">AndroidAutoSize</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/gunicorn/">Gunicorn</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Loop/"><div class="card-body"> <span class="timeago small" > May 8, 2022 <i class="unloaded">2022-05-08T19:44:52+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Looper分析</h3><div class="text-muted small"><p> 1. Looper的简单介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * Class used to run a message loop for a thread. Threads by d...</p></div></div></a></div><div class="card"> <a href="/posts/Handler/"><div class="card-body"> <span class="timeago small" > Jun 19, 2022 <i class="unloaded">2022-06-19T12:29:31+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Handler分析</h3><div class="text-muted small"><p> 1. Handler相关类总结 Handler ：用于发送和接收消息,是最外层的入口 Message：消息实体,实现了Parcelable接口,内部实现了单链表 Looper ：用于轮询消息队列，一个线程只有一个Looper MessageQueue：消息队列，用于存储消息和管理消息 ThreadLocal : 提供线程本地变量的存储 在把上述的5个类都分析一遍后,...</p></div></div></a></div><div class="card"> <a href="/posts/Handler-native/"><div class="card-body"> <span class="timeago small" > Sep 14, 2023 <i class="unloaded">2023-09-14T23:30:49+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MessageQueue的Native方法分析</h3><div class="text-muted small"><p> 前置 Handler并没有直接调用native，而是通过MessageQueue 相关的主要native代码 1 2 frameworks/base/core/jni/android_os_MessageQueue.cpp system/core/libutils/Looper.cpp MessageQueue.java中native方法的分析 路径 frameworks/base/c...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/AndroidAutoSize/" class="btn btn-outline-primary" prompt="Older"><p>AndroidAutoSize 1.2.1 源码分析</p></a> <a href="/posts/MessageQueue/" class="btn btn-outline-primary" prompt="Newer"><p>MessageQueue分析</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/kkyflying">kky</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/handler/">Handler</a> <a class="post-tag" href="/tags/framework/">Framework</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag" href="/tags/messagequeue/">MessageQueue</a> <a class="post-tag" href="/tags/c-c/">C/C++</a> <a class="post-tag" href="/tags/nginx/">Nginx</a> <a class="post-tag" href="/tags/androidautosize/">AndroidAutoSize</a> <a class="post-tag" href="/tags/django/">Django</a> <a class="post-tag" href="/tags/gunicorn/">Gunicorn</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://kkyflying.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
